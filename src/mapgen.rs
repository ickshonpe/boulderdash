use mapping::*;
use pos::*;


   pub fn put_border_wall(map: &mut LevelMap) {
      let r = map.rect();
      for i in r {
         if i.x == r.min_x
            || i.x == r.max_x
            || i.y == r.min_y
            || i.y == r.max_y {
            put_wall(map, i);
         }
      }
   }

   pub fn put_wall(map: &mut LevelMap, p: Pos) {
      map[p].tile = Tile::Wall;
   }


pub fn level1<'a>() -> Vec<&'a str> {
   let mut data = vec![
      "##########",
      "#~~~~~~~X#",
      "#~~~~~~~~#",
      "#~~..*.~~#",
      "#~~.*..~~#",
      "#~~..*.~~#",
      "#~~.*..~~#",
      "#~~~~~~~~#",
      "#p~~~~~~~#",
      "##########"];
   data.reverse();
   data
}

pub fn level2<'a>() -> Vec<&'a str> {
   let mut data = vec![
      "#############################",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#~~~~~~~~~~~~~*~~~~~~~~~~~~~#",
      "#~*~~~~~~~~~~***~~~~~~~~~~*~#",
      "#~~*~~~~~~~~*****~~~~~~~~*~~#",
      "#~*~~~~~~~~~~***~~~~~~~~~~*~#",
      "#~~*~~~~~~~~~~*~~~~~~~~~~*~~#",
      "#~*~~~~~~~~~~~~~~~~~~~~~~~*~#",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#######~#############~#######",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#                          %#",
      "# ~~~~~ ~~~~~ X ~~~~~ ~~~~~ #",
      "#%                          #",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#######~#############~#######",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#~~~~~~~~~@~~~~~*~~~~~~~~~~~#",
      "#~~@~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#~~~~~~~*~~~~~~~~~~~@~~~~~~*#",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~#",
      "#~~~~@~~~~~*~   ~~~~~~~~@~~~#",
      "#~~~~~~~~~~~~ p ~*~~~~~~~~~~#",
      "#~~~~~~~~~~~~   ~~~~~~~~~~~~#",
      "#############################"];
   data.reverse();
   data
}

pub fn level3<'a>() -> Vec<&'a str> {
   let mut data = vec![
      "##############################################",
      "#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@X#",
      "#~~~@~~~~~*~~~~~~~~~~~~%~~~~~~~~*@~~~~~~~~@@@#",
      "#~~~~~~~~~*~~~~~~~~@~~~ ~~~~~@@@**@@@~~~@@~~~#",
      "#~~~~~~~~~~~~~~~~~~@~~~ ~@~~~~~~~**@~~@~~~~~~#",
      "#~~~~@~~~~*~~~~~~~~~~~~ ~@@~~@~~~~**@@~~~~~~~#",
      "#~~~~~~~~~*~~~~~~~~~~## ~~@@@@@~~~~***@~~~~~~#",
      "#~~~~~~~~~*~~~~~~~~~~## ~~~~~~~~~~~~~***~~~~~#",
      "#~%                                        %~#",
      "#~~~~@~~~~*~~~~~~~~~~~~ ~~@@@~~*~~~~~~~~@@@~~#",
      "#~~~~~@~~@*~~~~~~~~~~~~ ~~*****~~~~~~~~~~~~~~#",
      "#~~~~~~*******~~~~~~~~~ ~~~~~~~*~~~~~~~~~~~~~#",
      "#~~~~~~~~~*~~~~~~~~~~~~ ~~~~~~~~*~~~~~~~~~*~~#",
      "#~~~~~~~~~*~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~**~~#",
      "#~~~~~~~~~~~~@~~~~~~~~~%~~~~~~~~~~~~~~~~~****#",
      "#p~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*****#",
      "##############################################"];
   data.reverse();
   data
}

pub fn read_map(data: &Vec<&str>) -> LevelMap {
   let x_len = data[0].len();
   let y_len = data.len();
   println!("x len, y len = {}, {}", x_len, y_len);
   let mut new_map = LevelMap::new(x_len, y_len);
   let mut p = Pos::zero();
   for row in data {
      println!("{}", p);
      for c in row.chars() {
         let tile =
            match c {
               '#' => { Tile::Wall }
               '~' => { Tile::Mud }
               '*' => { Tile::Diamond }
               '%' => { Tile::Monster }
               'p' => { Tile::Player }
               'X' => { Tile::Exit }
               '.' => { Tile::Empty }
               '@' => { Tile::Boulder }
               ' ' => { Tile::Empty }
               _ => { panic!("Tile character not recognised. {}", c) }
            };
         print_glyph(tile);
         new_map[p].tile = tile;
         p.x += 1;
      }
      p.x = 0;
      p.y += 1;
   }
   new_map
}

